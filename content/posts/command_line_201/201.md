+++
title = "Command line 201"
date = "2022-05-14T14:30:35+01:00"
author = "Lp1"
authorTwitter = "lp1dev" #do not include @
cover = "/cli201.png"
tags = ["meta", "hacking", "courses","terminal","command-line"]
keywords = ["hack", "courses","command-line"]
description = "Command line for advanced beginners"
showFullContent = false
+++

<script type="text/javascript">
function checkAnswers() {
    let responses = [
          "Question 1 [STATUS] : The answer was /dev/stdin since we need to read user input here.",
          "Question 2 [STATUS] : The answer was /dev/stderr, this is the special file reserved for error messages.",
          "Question 3 [STATUS] : The answer was /dev/stdout, this is the file that should be used to display information for the users in a terminal.",
    ]
    let questions = document.querySelectorAll('fieldset')
    let answers = ['#res0','#res07','#res11']
    let valid = [false, false, false]

    let i = 0
    for (let question of questions) {
          let answer = question.querySelector(answers[i])
          valid[i] = answer.checked
          alert(responses[i].replace('STATUS', (answer.checked ? 'True' : 'False')))
          i += 1
    }
    console.log(valid)
}
</script>


---

# Introduction

Welcome to this second command-line class! 

If you didn't follow Command-line 101 and need to grasp the basics of command-line and Linux click [here](../command_line_101).

In this class, we'll go further down the rabbit hole and learn how to use more advanced command and chain multiple commands together.

This class is supposed to be followed with [hack.courses](https://hack.courses) open alongside, the challenges are made to be completed in the website's interactive terminal.

![Hack.courses terminal](/screenshot.png)

---

# Input/Outputs

## Linux filesystem

Let's start this course by talking about the way inputs and outputs are handled on Linux systems!

Inputs and outputs are quintessentials for operating systems and such important features are usually handled by the *most important* and basic part of it : the **kernel**.

> **Definition** : A **kernel** is basically what you have left when you remove every executable, service and configuration file on your system, it's the part that handles your filesystems, users, groups, permissions and essential hardware.

Each kernel follows its own paradigms, regarding Linux, there is a famous saying in IT and Computer Science :

> "In Linux, everything is a file"

Which might sound odd as a concept. 

It actually just means that the way the Linux kernel handles most things is by creating or allowing you to create entries for them in the filesystem.

For instance, if you plug in a new webcam into your GNU/Linux machine, a new file will be created in the */dev/* directory for it. 

Those files are named **special files**. 

If you want to access a process's environment variables, you can read the contents of the */proc/self/environ* file.

## Standard inputs and output

We will now describe some of the more oftenly used special files, those are the ones your shell uses in order to read user inputs and display processes outputs.

### /dev/stdin

Also known as the **standard input** (stdin), */dev/stdin* is the special file programs such as **shells** use in order to handle your keyboard input.

<!-- todo link to definition "shell" -->

Whenever you type something in a terminal emulator, it will be written to */dev/stdin*, then read by whatever program is waiting for user input.

### /dev/stdout

Also known as the **standard output** (stdout), */dev/stdout* is the special file programs use in order to display text output for the user.

When a process needs to display content inside your terminal window, it will write it inside this file which is coutinuously read by terminal emulators.

### /dev/stderr

Also known as the **error output** (stderr), */dev/stderr* is the special file programs use in order to display error output for the user.

It works the same way the *standard output* does, but having two different data streams makes the distinction between errors and "normal" messages from a program easier.

### /dev/null

*/dev/null* is often called "the null device" or the black hole. Everything sent/written to this special file will not be stored and disappear.

It comes in handy if you want to disregard a program's error or standard output for instance.

### Summary

![](/io.svg)


### /dev/random and /dev/urandom

*/dev/random* and */dev/urandom* are random data generators. 

Whenever they are read, random data is generated. The slight difference between those two special files is that if */dev/random* will wait for enough entropy to be generated by a system before sending data. In a nutshell :

- */dev/random* might block the execution of a program if doesn't have enough entropy available
- */dev/urandom* will not stop generating data in any case, but will produce data that might be less random
- */dev/urandom* is suitable for most usages though, even cryptographic ones

> **Hint** : You can have a look at the data generated by */dev/random* and */dev/urandom* using `cat /dev/urandom` for instance. 
It might randomly write character sequences which break your terminal, it's okay though, you can just reload the page or press CTRL+C multiple times to stop `cat`, then type `reset` to reset your terminal.


---

## Quizz 1

Let's have a small quizz this time before we *actually* start tinkering, shall we?

<fieldset>
    <legend>Question 1</legend>

I am writing a program that requires the user to write their name in the terminal, which special file will I use?
<div>
      <input type="radio" id="res0" name="res" value="0"
             checked>
      <label for="0">/dev/stdin</label>
    </div>

<div>
      <input type="radio" id="res01" name="res" value="1">
      <label for="1">/dev/stdout</label>
    </div>

<div>
      <input type="radio" id="res02" name="res" value="2">
      <label for="2">/dev/stderr</label>
</div>

<div>
      <input type="radio" id="res03" name="res" value="3">
      <label for="3">/dev/null</label>
</div>


<div>
      <input type="radio" id="res04" name="res" value="3">
      <label for="3">/dev/urandom</label>
</div>

</fieldset>

<fieldset>
    <legend>Question 2</legend>


If my program encouters an error and I want to report it to its user, which special file will I use?

<div>
      <input type="radio" id="res05" name="res2" value="0"
             checked>
      <label for="0">/dev/stdin</label>
    </div>

<div>
      <input type="radio" id="res06" name="res2" value="1">
      <label for="1">/dev/stdout</label>
    </div>

<div>
      <input type="radio" id="res07" name="res2" value="2">
      <label for="2">/dev/stderr</label>
</div>

<div>
      <input type="radio" id="res08" name="res2" value="3">
      <label for="3">/dev/null</label>
</div>

<div>
      <input type="radio" id="res09" name="res2" value="3">
      <label for="3">/dev/urandom</label>
</div>

</fieldset>


<fieldset>
    <legend>Question 3</legend>

This one is a little bit more tricky : In the same program, I have generated a private key using random data and need to display it in the user's terminal for them to copy/paste. 

Which special file will I write to in the end?

<div>
      <input type="radio" id="res10" name="res3" value="0"
             checked>
      <label for="0">/dev/stdin</label>
    </div>

<div>
      <input type="radio" id="res11" name="res3" value="1">
      <label for="1">/dev/stdout</label>
    </div>

<div>
      <input type="radio" id="res12" name="res3" value="2">
      <label for="2">/dev/stderr</label>
</div>

<div>
      <input type="radio" id="res13" name="res3" value="3">
      <label for="3">/dev/null</label>
</div>

<div>
      <input type="radio" id="res14" name="res3" value="3">
      <label for="3">/dev/urandom</label>
</div>

</fieldset>

<div>

<button onclick="checkAnswers()">Check my answers</button>

</div>


---
---

Make sure you correcly understood everything in there, those are important concepts for the rest of this course which will make the content of the other classes easier to grasp. 

Whenever you're ready, move on to :

## [Command-line 202](../202)
